By the end of this week, you will be able to...

Describe a strategy for solving new problems
Give an example of an algorithmic problem and apply our problem solving strategy to this example
List evaluation criteria for effective algorithmic problem solving sessions
Critique others and yourself in solving algorithmic problems on the fly

=====
So the first thing that you want to do when you're asked a question is to make sure that you really understand what's being asked. What the parameters involved are and what the goal for the solution would be. And so your first task is to ask lots more questions. When faced with a hard question ask as many questions as you can think of to tease out the relevant assumptions that the interviewer has in mind, or that might be relevant for your solution to tease out the scope of the problem that's being asked. And to try to understand what it is that you're trying to analyze and to solve. Now once you've asked a lot of questions to make sure that you clarify the problem and know where to go, what you should do is confirm your understanding by working through an example. And working through an example is really useful because both it lets you get those creative juices flowing and start thinking towards a solution. But it also lets you take some time and think through the problem very concretely about what difficulties might be involved, where are the sticking points of any solution we'd have to solve and also if there are any hidden assumptions or implicit questions that you might need to address again and go back to that first step of asking more questions of the interview to really make sure that you've mapped out the scope of the solution that you need to come up with.

You want to make sure that at least you got some approach to solving the problem that's being solved. So, at least even if it's not a good approach you've been able to do what's asked of you. And so we call this the brute force approach. You take a hammer and you hit the problem with it. You make sure that you can nail that problem down. You've got some way of tackling it. And this approach does not need to be clever. It doesn't need to be elegant, but you want to make sure that you've got a correct solution.

Make sure that your brute-force approach can handle both. And then think through a little bit if you were to implement this first solution, how would you do it? What data structures would be useful? How would those data structures would interact with the problem that you're working with? In particular, what performance would you get out of this implementation? And any trade-offs that you might be thinking about in terms of maybe using more memory to speed up the performance, or vice verse. So, we've got a solution. But we didn't spend very much time trying to make it clever or elegant. So our next step of the strategy is to iterate this whole process of coming up with a candidate approach to solving the problem, evaluating it, testing it, poking at it, making sure that it does what you want it to do, or if it doesn't, thinking about ways to fix it and really try and nail down as good a solution as we can.

And so only once we've done this very thorough analysis of the problem, I have a very good sense of what we want to implement, now you can start writing some code on the whiteboard.
=====

All right, so here's the question. We're given an array of integers and we would like to find the kth smallest integer.
So our first step is to ask lots of questions.
So here are a few that I came up with.

When we want to think about finding the kth smallest element of an array, we want to make sure that we are on the same page about what smallest means. Do we mean smallest magnitude or do we mean smallest on the number line? And this is relevant if we have negative integers in the array. So for example, if we have negative a thousand, that's got a very high magnitude but it's very much lower on the number line than say the integer one. So we want to just make sure that we're on the same page with the interviewer about what they're intending from the question. We also want to ask things about the structure of the array and what we're allowed to do with it. Are we given the array as a pre-sorted collection of elements, are they already organized? Or is that maybe up to us to decide how to to organize these elements? And speaking of which, when we're deciding what to do with those elements, are we allowed to change the array as given to us? Is it mutable, are we allowed to change it in place or do we need to make a copy of it? And then manipulate it as we see fit. Also about the array, it's useful to know if there are duplicate entries. Do we need to think about possibly some array elements having the same value? In that case, what do we exactly mean about kth smallest? Do we mean the kth smallest distinct value? Or do we mean the position sorry, the number in the case position when we order all the array elements including duplicates? And so this is something we would want to clarify with the interviewer. Going along with that question when we're talking about kth smallest, we want to make sure that we understand how k behaves. Are we starting the indexing at 0 or 1? And so we want to look at each of the words in the questions being asked. And really dig dip onto that word and understand how it's going to relate to the solution that we worked.
So now that we've understood the problem very well, it's usual to work through an example with not too few but not too many array elements so that we really confirm all the answers to the clarifying questions that we've asked. So it's good to think of an array example that has some of the possible strange behavior that you would expect if you want to maybe take into account negative integers. You might want to take into account 0, some positive integers. And this example is going to assume that our interviewer said there are no duplicate entries. But if he or she said that there might be duplicate entries, then you definitely want to take that into account, in the example that you work through. But right now, we're going to assume that there's no duplicates in our array. So we plop down a few numbers and now we ask ourselves, what would the solution, the expected response to our algorithm be if k were to be, say, 1 in this array of integers? And if k is 1, then we're looking for the smallest array element in this given array. And so we scan through the array elements and we see that the smallest value is -3. And so that would be our expected response. And then we could ask well what if k was 2? Well then, our problem is asking for the second smallest element and so we don't want to output -3 anymore, we want to output the next smallest which is 0. And one thing that's useful to do as you're working through this example is think about how you as the human is solving the problem for the small example. And keep in the back of your mind how would you generalize this strategy and write it down systematically, so that an algorithm could perform the same tasks. And then last but not least, we also want to think about some edge cases in this example. What would be the highest value of k that would make sense? And the highest value of k that would make sense would be the number of elements that we're given to begin with. Because if we ask for the eighth smallest array element in this collection, then what we are really asking for is the biggest element and so that would be 42 for this small example. And so as we're thinking through these cases, we might recognize it to ask for the eight smallest element is really asking for a symmetric problem about the largest. And so that might already get your wheels turning about a possible optimization later on in our algorithm. And we'll come back to that later, but first we're going to do the next step in our strategy which is just the naive implementation of brute force solution to the problem.
=====
So we've worked through this example and now we really understand the task at hand. And so it's good before we do the solution to just reaffirm what the assumptions that we're making are. And at this point, we know that our array is given to us without any information about how it's organized and it may have some duplicate elements. But we're allowed to change the array as we proceed with the algorithm. And so, we're looking for the kth smallest element. And what we might want to do is build up to the kth smallest element by looking for the smallest element and then the next smallest element and then the next smallest element after that and then keep on going until we've gone to the kth one. We notice that that's somewhat similar to the procedure that we have to do for selection sort. And with selection sort, we find the smallest element and we swap that to a first position of the array so that we can think about ignoring it afterwards or discarding it in some sense. And then we focus on the rest of the list and find the smallest element among those remaining elements, swap that to the beginning, and then just keep on focusing on the remaining elements. And this would give us an algorithm that's a variant of selection sort that we already know. And so it's always nice when we can use our previous knowledge to inform design of future algorithms. But before we go ahead and code this solution, let's analyze it to see if it's worth coding. Because it was just our first hunch at how we might solve this problem. And so it's good to stop and think and evaluate before we go further any one direction. And so if we evaluate the performance of this approach, what we're doing at each point is finding the minimum element of an array of numbers. And if we wanted to find the minimum amongst an array of elements, what we have to do is look at each one of those elements. And that takes linear time. And so even though the number of elements that we're considering each time decreases by one, we still might be doing this, we still are doing this k many times. And so, for really small k, if we just need to find the very smallest element or the second smallest element, in that situation, this would give a linear algorithm. But in the more general situation, where k maybe is n/ 2, and we're finding the element that is right in the middle, the median, then if we have to do this approach, say n/2 many times or any O(n)many times, then all of a sudden our algorithm becomes quadratic. And that's a problem. Because quadratic algorithms, they're kind of slow, especially if our problem has something to do with sorting. And so we've already seen how the algorithm that were devising is related to sorting, in the sense that it's related to the selection sort algorithm. And so maybe we can use that insight to come up with a better solution. And so what if we sorted the array before doing anything in terms of finding the kth element? And as a preprocessing step, let's just apply our favorite sorting algorithm and organize all the elements from smallest to biggest. And the advantage of doing that is that, at this point, the element that we care about, the kth smallest element, is in position k in the array. And accessing an element in a particular position in the array is a constant time operation. So overall, we've now come up with an algorithm that takes however long a sorting takes for the preprocessing step. And then O(1) time for the second step which is retrieving that kth smallest element. And the advantage of having these two separate steps is that sorting is a really well studied problem and we know that in the worst case there are still algorithms out there that solve sorting with n log n time.
And so that's a really big improvement to quadratic time. And so we're feeling pretty good that we've made a pretty dramatic improvement to our original naive approach to solving the problem, and now we have a slightly less naive approach. And at this point, we might be feeling comfortable enough with this approach to go and code it on the whiteboard.
=====
So now that we have a strategy in mind, we're ready to move to the white board and actually start implementing it. Pretending that we're in the live interview situation. You'll be talking with an interviewer and you'll be working with them next to a white board. Which means that we're not coding in an IDE or even on a computer. And so the strategies that we have for describing our code on the white board will be a little bit different from what we've talked about before. Let's work with the example we have so far. And remember, our strategy for finding the k'th smallest element and the array is to first sort the array, and then just pick out the k'th element. And so, let's go ahead and write that. And at this point, we might have asked the interviewer whether we should assume that the method is public or private. And maybe they said it doesn't matter, or maybe they said that it was public. And so we start with our header. And we know that we're supposed to be returning the value of the k'th smallest element, and so we're returning an int. And we want a descriptive method name, and so maybe we call this kthSmallest.

And as inputs, we have both the array of elements that we started with, as well as the rank. And so we have int array and we have the rank that we want to return. And so, here's our head method header. Now, the first thing we might want to do in our method is just make sure that we have some validation of the arguments and make sure that the parameters make sense. And so what we will do is check if (K i<=0 || K> array.length. In which case, it doesn't make any sense to ask for the k'th smallest. So in this situation, we want to thrown an exemption, because the arguments was just no good. And so, we're going to throw anew IllegalArgument

Exception And that's that. But really, the heart of the strategy is going to be if we do have good arguments and then our plan was to sort, and we can use a library method for that. We've got arrays.sort(array) and then we're going to return the element in the case position after we've sorted the array. We have to be a little bit careful. Remember, we talked about what we're assuming k is indexed by, and if we're thinking of k as starting with one, so we're talking about the first smallest is the minimum and then the second smallest, etc. Then what we want to return is the element of the array, rather than k.

And that will be that. And so what we have now on the board is a description of the algorithm that we've articulated for solving the problem. And what we would do now is perhaps walk through with an example. But before we do that, I want to step back away from the context of being in the interview and just talk a little bit about some good white boarding techniques and strategies. And so one thing you might notice in this sample code is that we used relatively meaningful names. So the method name is helpful to the reader as to what we're doing. Also in this code, I tried to keep a lot of space between the lines. And so if I needed to go in and then edit or add, or change some of the code later on, I would be able to fit some extra pieces of code in between the spaces. Because unlike a computer, we can't copy and paste. And we can't move things around very easily. And so it's good when we're first throwing some code on the board to try to give ourselves a potential for modifying it later. Something else you want to keep in mind is that you want to use variable names that are easy for the interviewer to see. So for example, K is a good choice for a letter that's being used for a variable name. You might say that if you were typing it up, you would use maybe an even more meaningful variable name like rink. But in the interest of time, so you don't have to write out all four letters each time, you're just going to use K. And a rule of thumb is that K is often a better choice than I or J, because those can, for one thing, look really similar to one another on the board. And also, they can be mistaken for semi-colons. You also want to make sure you're writing big enough and legibly, so that some one who is following along and reading with you can make sure they understand what's going on in the code, and then you can work on developing the algorithm further. And so at this point in the interview, the interviewer might go in a few different directions. They might ask for us to actually implement this sorting method instead of using a library call. Or they might ask us to go further with the algorithm.
=====

Okay, so at this point what we're going to do now is go further in the algorithm that we're developing. And, if you think back to what we did, we sorted the whole array before picking out the kth smallest element. Can we probe the solution, and can we really think about optimizations? And for example, maybe we don't need to sort the whole array, maybe the array is a huge chunk of memory, but we only care about k that is on the order of millions, not billions. And so what could we do if we were in that sort of a situation? And so at this point, you want to brainstorm and see what are other strategies we have for coming at that kth smallest element. And one data structure that we have that helps us keep elements in a somewhat organized fashion is a max-heap. And so, we know that in a max-heap, we have this tree structure whose root is the maximum element. And so, if we're looking for the kth smallest element in a group, and we have all k smallest elements arranged in a heap, then the root of that heap will be the kth smallest. It will be the biggest amongst the k smallest. And so maybe what we can do is build a heap of size k, where we want to make sure that the elements in that heap are the k smallest overall. And so let's think about how that would work with an example. We don't want to have all of the elements in our array in that heap. That heap would be too big. We just want to focus on the k smallest, and we're really taking advantage over here of the difference in magnitude between k, which is the rank that we're looking for, and the overall size of the array. And so if we restrict our heap to just three elements, say if k = 3. Than we might walk along our array and insert elements into the heap. And so we insert 17, that first element, into the heap. And then we insert the next element 42. And of course 42 becomes the root because it's bigger than 17. And then we insert 0 as well because we need three elements in our heap. And now we go ahead and look at 5. And we want 5 to be in our heap as well because it's smaller than 42, it's smaller than 17. And so it is a candidate for being one of the three smallest elements and that's what the heap is trying to capture, the three smallest elements overall that we've seen so far. And so what we're going to do is to swap out the current maximum element in the heap, remove it from the heap and put 5 in instead. And so 5 goes in and it has to go in, in its correct location so we still have a heap structure. And the advantage of that is now the 17 gets put to the root and so if we find some small element later on then we know that we're going to remove the biggest element in our current heap and put in the smallest element. So that at each stage we have, the heap is containing the three smallest elements that we've seen so far, and the root is the maximum of those. And so, we continue, we look at 10, and it's gotta go in instead of 17. We look at -3, it's gotta go in, but now 5 becomes the root, and we keep on going with 2 and with 9. And at this point we notice that our heap has three elements and so the third smallest element in our whole array is going to be the root of that heap, and that's beautiful because we can just read off the root of the heap. And,so, what we've done here is we've used a somewhat fancy data structure, but a very standard one that we have in our back pocket that we're prepared for. And we've used this property that the root is the maximum element of all of the elements in the heap. And that's helping us to solve this problem. And so this is a nice strategy. It's nice also that we're demonstrating some creative problem solving, some flexibility. So we're not focused on one particular problem solving strategy, but we're demonstrating that we're thinking about different avenues. And at this point, we might go ahead and code up this strategy. Now, this is a lot of code, and it would probably take us a few minutes to develop it on the whiteboard. What I want to focus on is that as we develop this code, we notice that we're using some data structures. And in those data structures, we're demonstrating that we're familiar with some Java libraries like the Collections library, like PriorityQueue. In particular, when implementing a max-heap, we need to reverse the order of the competitor and so we're demonstrating that we are relatively sophisticated programmers. We also wanted to test and analyze our new strategy. It's great that we are creative and came up with a new one, but we also want to see if we made any progress, if it performs any better than our very, very simple sort and then pick off the kth element strategy. And so, we can look through our code and look for where do we have function calls that take some time and how does the performance depend on k and on n. And what we notice is that at the beginning stage for the first k elements of the array, we're just adding each one of them into the heap. Add, add, add, put them into the heap. And then afterwards, we're only adding into the heap if the current array element that we're looking at is really smaller than the maximum element at the root of the heap. And only at that point do we swap the current element into the heap. Now in each of those situations, we have to do some heap operations we're adding into the heap and we're removing the root of the heap as well. And so here it's important to know that heap operations like insert and remove take time that's logarithmic in the size of the heap. Because we might have to traverse all the way down to the bottom of a path and the maximum length path, it could be at worse log the size of the heap log, the size of the tree. And so we see that we're doing these operations. We're doing a constant number of these operations for each array element that we're looking at and so all in all, this algorithm is going to have performance that's O( n log k). And that's interesting because we can compare this performance to what we had before. And again, we're demonstrating our critical thinking, our analysis of the two algorithmic approaches that we have. And before we had an algorithm that was O(n log n), and now we have O(n log k). And so we've made some improvement if, in particular, k is going to be much smaller than n but still grows, and so we still want to take that into account.
So this is a very very different problem solving strategy from the first one we saw. And we might go even further and that's what we'll do next.

=====
All right, so now for something completely different, we're going to find yet a third algorithm, it's not going to be the sort then probe algorithm we started with and coded on the white board. It's not going to be the algorithm that relies on the max heap that we just talked through. But rather what we can think about is Going through our arsenal of sorting algorithms, what else is useful?

We have a really interesting sorting algorithm from Quick sort where we use a pivot behavior and we recursively sort different parts of the array based on partitioning the array into the smaller than the pivot and larger than the pivot. And so, what we can do now is recognize that sorting was useful for solving our new problem. And so maybe we can use a sorting algorithm and modify it in some way to make a new algorithm that's useful for the current problem. The problem of finding the k'ths smallest element. So what if we picked a pivot in our elements, in our array of elements and thought through what happens when we sort the, not sort, partition the array into the elements that are smaller than the pivot and those that are bigger than the pivot. Now, we're not looking for fully sorted array at the end of this procedure, what we want is the k'ths smallest element. And what's really useful here is that if we partition the array into those that are smaller than the pivot and those bigger than the pivot, than if we only have say three elements that are smaller than the pivot. Then the third smallest element over all is going to be the maximum of those three elements because the pivot's going to be bigger and all of the other elements in the array are going to be bigger than those bottom three elements. And so they're not going to be the third smallest and so the beauty of this approach is going to be that we only need to recursively look at only roughly half of the elements each time if we're lucky with our choice of pivot. And so what we can do is at each stage pick some random element of the array. Partition the array into those elements that are smaller than the pivot, those elements that are bigger than the pivot. And then look at the size of the set of elements, is it smaller than the pivot and compare that size to the ring. Because that size of that set is going to tell us whether the k'th smallest element belongs in that set of elements that are smaller than the pivot, or maybe that k'th smallest element is the pivot. Or maybe that case smallest element is bigger than the pivot and so we need to look in the rest of the elements in the array. And so we can code up this strategy and notice that this is going to be a recursive method. Which is great if we can come up with a recursive solution. To our problem strategy, we're demonstrating yet another skill in programming and algorithmic development in our interview, we're demonstrating our breadth of knowledge, and we want to still be careful about the code that we write. We're doing the input validation. We have a helper method, and so we're demonstrating that we know the difference between the private helper methods And the public method call that we have. And then as we go through this recursive function development, it's going to be very important to test the code, which is why we had that base example that we can keep tracing through. Now as we develop this new strategy, we still want to think about performance, and the performance is going to hinge on the fact that when we compare to the pivot at each recursive function call. We hope that we're going to divide our array of elements into the smaller thans and the bigger thans and those are going to be hopefully, roughly the same size to one another and so we get to reduce our problem size exponentially by reducing the array size in half each time. And so what we're hoping for, on average at least, is linear time. And a careful analysis of the recursive performance of that function would really get us at its expected on time. Now in an interview situation this might seem a little daunting to come up with such an elaborate algorithm and to do its performance analysis. But here's the punchline. What we want to make sure to do in the interview is always keep going. We never want to be content with the solution that we have at hand. And so when we do have a solution, it's really important that we think about, does it match the assumptions that we made at the beginning? How will we change it if we had different assumptions, if for example we allowed repeated elements in the array, what would we have to do differently in our methods? We want to consider performance every time we come up with a new problem solving strategy. Have we made progress or maybe have we gone backwards? Are we coming up with better solutions or are we coming up with just different solutions? And then are there tradeoffs that we can consider there for time versus memory? And keep going, keep going. Think of ways that we can bring in our tools. What we want to do is through our practice, have a wide array of tools that we can apply to new problems. It may well happen that you've done so much practice that in the interview situation you're asked a question that you've already solved. Now, it's really important in this situation to mention that you've actually worked through that solution. And then the interviewer might ask you to still write out the solution, but then they might ask you to go further, like we did, with those different algorithms and take different assumptions or take different paths so you can demonstrate your novel problem solving skills. And when we are approaching a problem that's very new what's useful is when we've done all that practice that we can go through a mental checklist of all the useful data structures that we have and all of the known algorithms that we've worked through. And really help solve the new problem using what we've done before.

=====
Data structures, algorithms and code constructs you'll need for your interview

Throughout this course we've talked about several data structures and algorithms you'll need to have in your toolbox as you approach an interview. Here we're providing a list of the most important ones. You should probably know how to (1) use, (2) implement, and (3) analyze the running time of all of the data structures and algorithms listed below. This is not an exhaustive list by any means, and if you know of more, please post them in the forum. If the post gains enough momentum, we'll pin it to the top.

Most of these concepts are covered to some degree in the previous courses in our specialization, but it never hurts to find other sources and study them as much as possible. And don't try to "just memorize" anything. If your understanding of these concepts is solid, you'll be much better off in a high-stress situation!
Data Structures and Abstract Data Types

    Arrays

    Linked Lists: single and double, with and without sentinel nodes
    The List ADT
    Trees: Binary and otherwise, BSTs
    The Set ADT
    Tries
    Heaps
    Stack, Queue and Priority Queue ADTs
    Graphs: directed and undirected, different representations and their trade-offs
    Hashtables: collision resolution strategies, hash functions and their trade-offs
    The Map ADT

Algorithms

    Binary search
    Sorting algorithms: Selection Sort, Insertion Sort, Bubble Sort, Quicksort, Mergesort, Heapsort
    Search algorithms: Depth-first search, Breadth-first search, Dijkstra's algorithm
    Tree traversal: pre-order, post-order, in-order, level-order (which is BFS)
    Algorithm techniques: Brute force, Divide and conquer (e.g. Mergesort), Greedy, Dynamic Programming (more advanced, OK not to know if you are at an intermediate level)
    NP-hard problems

Basic Java Programming Constructs

    All the very basics of course (loops, conditionals, functions, etc)
    Input and output: from files and command line
    The String and Character class
    Converting between data types
    Object oriented design and concepts: Inheritance and Polymorphism, Classes and Objects, static and non static, access level modifiers (public, private, protected)
    The java.util library (including all of the container classes)
    The Iterator pattern (more advanced, probably OK not to know if you are at an intermediate level)
    Exception generation and handling
    Event-driven programming
    Inner classes and anonymous classes (slightly more advanced, but good to know about)
    Lambda expressions (more advanced)