 Конспект "Умные указатели".
std::auto_ptr

Не использовать! Устарел! Отсутствует в стандарте C++11!

Устаревший владеющий указатель. Чтобы избежать соблазна использовать этот тип "умного" указателя, про него ничего не напишем, хотя в видеолекциях этот материал присутствует!

Но для любопытных всегда есть документация: http://www.cplusplus.com/reference/memory/auto_ptr/
std::unique_ptr

Владеющий указатель, то есть это значит, что на один объект указывает ровно один указатель. Как только указатель уничтожается (например, мы выходим за область видимости), для объекта вызывается delete. Так же мы можем освободить указатель с помощью вызова метода reset.

std::unique_ptr<Foo> PFoo1(new Foo());
std::unique_ptr<Foo> PFoo2;

PFoo2 = PFoo1; // Нельзя! Синтаксическая ошибка!
PFoo2 = std::move(PFoo1); // Правильно! Теперь на объект указывает PFoo2, а PFoo1 не указывает никуда.

PFoo2.reset(); // Тут объект уничтожается.


Документация: http://www.cplusplus.com/reference/memory/unique_ptr/

std::shared_ptr

Указатель со счетчиком ссылок. Допускает совместное владение объектом, то есть много указателей может указывать на один объект. Общект уничтожается с потерей последнего указателя на него (когда счетчик ссылок станет равным нулю). Метод reset тоже существует.

std::shared_ptr<Foo> PFoo1(new Foo());
std::shared_ptr<Foo> PFoo2;

PFoo2 = PFoo1; // Можно! Теперь ОБА указателя указывают на один объект.

PFoo1.reset();
PFoo2.reset(); // Тут объект уничтожается.


Документация: ﻿http://www.cplusplus.com/reference/memory/shared_ptr/

std::weak_ptr

Слабый указатель. Является "ручным" средством борьбы с циклическими ссылками. Имеет метод lock, который возвращает "сильный" указатель ﻿std::shared_ptr.

﻿std::shared_ptr<Foo> PFoo(new Foo());
std::weak_ptr<Foo> WeakPFoo = PFoo;

{
    std::shared_ptr<Foo> LocalPFoo = WeakPFoo.lock();
    // Тут работа с LocalPFoo.
} // Тут LocalPFoo уничтожается.


Документация: http://www.cplusplus.com/reference/memory/weak_ptr/﻿