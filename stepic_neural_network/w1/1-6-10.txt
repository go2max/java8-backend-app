
Как считать данные из файла:

>>> sbux = np.loadtxt("sbux.csv", usecols=(0,1,4), skiprows=1, delimiter=",",
                      dtype={'names': ('date', 'open', 'close'),
                             'formats': ('datetime64[D]', 'f4', 'f4')})
>>> print(sbux[0:4])
[(datetime.date(2015, 9, 1), 53.0, 57.2599983215332)
 (datetime.date(2015, 8, 3), 58.619998931884766, 54.709999084472656)
 (datetime.date(2015, 7, 1), 53.86000061035156, 57.93000030517578)
 (datetime.date(2015, 6, 1), 51.959999084472656, 53.619998931884766)]


Здесь использованы не все параметры функции loadtxt (полный их список можно посмотреть в справке). Разберём имеющиеся, так как они являются наиболее часто встречающимися.
"sbux.csv" — имя файла (или сюда же можно передать объект файла, такой пример вы увидите в следующей задаче урока), из которого считываются данные.
usecols — список колонок, которые нужно использовать. Если параметр не указан, считываются все колонки.
skiprows — количество рядов в начале файла, которые нужно пропустить. В нашем случае пропущен ряд заголовков. По умолчанию (если значение параметра не указано явно) skiprows = 0.
delimiter — разделитель столбцов в одной строке, в csv-файлах это запятая, по умолчанию разделителем является любой пробел (в том числе — знак табуляции).
dtype — словарь из названий колонок (переменных) и типов хранящихся в них значений. NumPy использует свою собственную систему типов, и названия именно этих типов нужно указать. По умолчанию функция попытается самостоятельно угадать, какому типу принадлежат подаваемые на вход значения.
