<head>
<meta charset="UTF-8">
</head>
<body>
<pre>
Дана программа, проверяющая корректный хеш введенной строки. Функция хеша распаковывается 
покомандно и исполняется на стеке.(для усложнения задачи можно снять права на исполнение стека).

Для решения нужно 
1) Вытащить коэффициенты дискретного косинусного преобразования и провести его, получив покомандно код
хеш-функции.
2) Протрассировать программу, вытащив коды хеша прямо со стека, восстановив код хеша.

После получения кода хеша нужно перебрать 8 символов и получить нужную строчку с хешем.
Хеш-функция в итоге просто проксоривает различные части строки из 8 байт друг с другом и с константами.
Если выписать алгоритм, то можно перебрать 256 вариантов и найти среди них верный ключ.

Подробный алгоритм решения:
1) Коэффициенты, лежащие в памяти, нужно преобразовать по обратному дискретному косинусному преобразованию:
q1=[	255037122.0,	21228535.6118,-31222210.0099,	32787438.909,	-67417641.7612,
	-74270237.8351,-20427819.8469,-6292819.17092,	-16225114.2612,	-20437144.9698,
	-28156796.7643,-34376782.6837,11241782.3525,	115468022.912,	4863824.80768,
	26436635.1965,	62538224.0342,-33011432.1142,	-39764910.7944,	-8608542.09469,
	-3089987.61241,-11055025.7609,1304209.85595,	-15692216.0]
q2=[	254612100.0,	14027280.6281,-18784685.5744,	35210085.7106,	-60778878.333,
	-54393839.4879,-31986439.8741,-28616874.5518,	-15757295.0602,	2670129.26556,
	-79931500.0356,-6838426.50206,68760875.0765,	16732018.0,	582881.752764,
	51517017.2399,	4467959.98166,17323759.1217,	29756440.1578,	-33108393.768,
	52029323.5888,	-23700083.7673,-108993287.426,	-36736303.4412,	29052879.7462,
	45939111.5525,11178756.0]
from scipy.fftpack import *
code1 = idct(q1,1)
code2 = idct(q2,1)
2) В результате получится два массива чисел q1 и q2. Каждое число нужно сохранить в файле побайтно
   в формате Little Endian. Полученный файл дизассемблируется и получается две процедуры
unsigned int hash1 (char * key_val_ref){
	__asm{
		push ecx
		push esi
		mov esi, key_val_ref
		
		xor ecx,ecx
		mov eax, dword ptr [esi]
		xor ecx, eax
		xor cl, 0xFE
		xor ch, 0xCA
		ror ecx,8
		xor cl, 0xBE
		xor ch, 0xBA
		ror ecx,8
		
		mov eax, dword ptr [esi+4]
		xor ecx, eax
		xor cl, 0x7F
		xor ch, 0x5C
		ror ecx,8
		xor cl, 0xF5
		xor ch, 0xC7
		ror ecx,8
		
		xor cl, 0x96
		xor ch, 0x83
		ror ecx,8
		xor cl, 0x13
		xor ch, 0x50
		ror ecx,8
		
		mov eax, ecx
		pop esi
		pop ecx
	}
}
unsigned int hash2 (char * key_val_ref){
	__asm{
		push ecx
		push esi
		mov esi, key_val_ref
		
		xor ecx,ecx
		mov eax, dword ptr [esi]
		xor ecx, eax
		xor cl, 0xAC
		xor ch, 0xFA
		ror ecx,8
		xor cl, 0xAF
		nop
		xor ch, 0xCA
		ror ecx,8
		
		mov eax, dword ptr [esi+4]
		rol eax, 8
		xor ecx, eax
		xor cl, 0xEF
		nop
		xor ch, 0x5E
		ror ecx,8
		xor cl, 0xAC
		xor ch, 0xFC
		ror ecx,8
		
		xor cl, 0x45
		xor ch, 0x65
		ror ecx,8
		xor cl, 0x65
		xor ch, 0x24
		ror ecx,8
		
		mov eax, ecx
		pop esi
		pop ecx
	}
}		
3) Ключ должен состоять из печатаемых символов, которые имеют hash1(key)==0xbffeefac и hash2(key)==0x213f522
Заметим, что исходя из исходников процедур
	a[0] ^ 0xFE ^ a[6] ^ 0xC7 ^ 0x96 = 0xFE
	a[1] ^ 0xCA ^ 0xBE ^ a[7] ^ 0x83 ^ 0x13 = 0xbf 
	a[2] ^ 0xBA ^ a[4] ^ 0x7F ^ 0x50 = 0xAC 
	a[3] ^ a[5] ^ 0x5C ^ 0xF5  = 0xef

	a[0] ^ 0xAC ^ a[5] ^ 0xFC ^ 0x45 = 0x13
	a[1] ^ 0xFA ^ 0xAF ^ a[6] ^ 0x65 ^ 0x65 = 0x02
	a[2] ^ 0xCA ^ a[7] ^ 0xEF ^ 0x24 = 0x22
	a[3] ^ a[4] ^ 0x5E ^ 0xAC = 0xF5
8 уравнений, 8 неизвестных. Ключ 53Kur3dh удовлетворяет всем этим условиям. Всего тут 256 верных последовательностей
байт, среди которых нужно выбрать читаемую строчку.
4) Решение на python
#!/usr/bin/python

def testt(s):
        for c in s:
                if ord(c) >= ord('0') and ord(c) <='z':
                        continue
                else:
                        return 0
        return 1
a=['','','','','','','','']
for c in range(127):
        a[0] = chr(c)
        a[6] = chr(0xFE ^ ord(a[0]) ^ 0xC7 ^ 0x96 ^ 0xFE)
        a[5] = chr(ord(a[0]) ^ 0xAC ^  0xFC ^ 0x45 ^ 0x13)
        a[3] = chr(ord(a[5]) ^ 0x5C ^ 0xF5  ^ 0xef)
        a[1] = chr(0xFA ^ 0xAF ^ ord(a[6]) ^ 0x65 ^ 0x65 ^ 0x02)
        a[7] = chr(ord(a[1]) ^ 0xCA ^ 0xBE ^ 0x83 ^ 0x13 ^ 0xbf)
        a[4] = chr(ord(a[3]) ^ 0x5E ^ 0xAC ^ 0xF5)
        a[2] = chr(0xCA ^ ord(a[7]) ^ 0xEF ^ 0x24 ^ 0x22)
        if testt(a):
                print "".join(a)
Дает 16 возможных ключей
06Npw6am
17Oqv7`l
24Lru4co
35Mst5bn
42Jts2ei
53Kur3dh - верный ключ.
60Hvq0gk
71Iwp1fj
8>Fx>ie
9?Gy~?hd
:<Dz}<kg
;=E{|=jf
<:B|{:ma
=;C}z;l`
>8@~y8oc
?9Ax9nb

</pre>
</body>
